/*2.1. Квадратное озеро (6)

Квадратное озеро с островами задается матрицей размером N х N (1 <= N <= 300). Каждый
элемент матрицы содержит либо символ '@' (собака), обозначающий территорию, которая
включает часть острова, либо символ '.' (точка), обозначающий участок свободной воды. В левом
верхнем углу озера находится квадратный плот размером M x M (1 <= M < N) клеток.
За один шаг плот может сдвигаться на одну клетку по горизонтали или вертикали. Плот и
остров не могут иметь общих клеток. Требуется определить минимальное число шагов,
необходимых для того, чтобы плот достиг правого нижнего угла озера.
Ввод из файла INPUT.TXT. В первой строке содержатся числа N и M, разделенные пробелами.
В следующих N строках находится матрица, представляющая озеро, по N подряд идущих
символов в строке. Подматрица размером M x M, находящаяся в левом верхнем углу, не содержит
островов, то есть начальное положение плота всегда допустимо.
Вывод: файл OUTPUT.TXT должен содержать единственное число — количество
необходимых шагов. Если правого нижнего угла достичь невозможно, то в файл выводится No.

Пример
Ввод  1       Ввод  2      Ввод  3
7 2           7 3          7 3
.......       .......      .......
...@...       .....@@      .....@@
.......       ......@      ......@
..@....       .@.....      .@....@
.......       .@.....      .@.....
.......       .......      .......
....@..       ..@@...      ..@@...
Вывод  1      Вывод  2     Вывод  3
10            8            No*/


#include "stdafx.h"
#include "Pathfinding.h"
#include <chrono>
#include <iostream>

int _tmain()
{
	auto pointBefore = std::chrono::system_clock::now();
	int fieldSize, shipSize;
	ifstream inputFile("input.txt");
	if (ReadingAndCheckingInputData(inputFile, fieldSize, shipSize))
	{
		Pathfinding_f(inputFile, fieldSize, shipSize);

		auto pointAfter = std::chrono::system_clock::now();
		auto durationMsec = std::chrono::duration_cast<std::chrono::milliseconds>(pointAfter - pointBefore);
		std::cerr << "Total time: "<< durationMsec.count()<< "ms" << std::endl;
		
		return EXIT_SUCCESS;
	}
	else
	{
		return EXIT_FAILURE;
	}
}